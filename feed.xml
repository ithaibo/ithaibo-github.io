<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="http://jekyllrb.com" version="3.4.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-02-26T15:29:21+08:00</updated><id>http://localhost:4000/</id><title type="html">Andy’s Blog</title><subtitle>这是我的个人Blog
</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2017/02/26/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2017-02-26T14:15:13+08:00</published><updated>2017-02-26T14:15:13+08:00</updated><id>http://localhost:4000/jekyll/update/2017/02/26/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2017/02/26/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Vieweventdispatch</title><link href="http://localhost:4000/2017/02/26/ViewEventDispatch.html" rel="alternate" type="text/html" title="Vieweventdispatch" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/ViewEventDispatch</id><content type="html" xml:base="http://localhost:4000/2017/02/26/ViewEventDispatch.html">&lt;h1 id=&quot;view事件的分发机制&quot;&gt;View事件的分发机制&lt;/h1&gt;
&lt;p&gt;View的一大难题：滑动冲突，解决办法就涉及到事件分发机制。&lt;/p&gt;

&lt;p&gt;点击事件的传递规则
点击事件MotionEvent。点击事件的分发，其实就是对MotionEvent事件的分发过程。当一个MotionEvent产生了以后，系统需要把这个事件传递给一个具体的View，而这个传递的过程就是分发过程。点击事件的分发过程由三个很重要的方法来共同完成：dispatchTouchEvent、onInterceptTouchEvent和onTouchEvent。&lt;/p&gt;

&lt;p&gt;dispatchTouchEvent
用来进行事件分发
onInterceptTouchEvent
判断是否拦截某个事件
onTouchEvent
处理点击事件，在dispatchTouchEvent中调用&lt;/p&gt;

&lt;p&gt;三个方法的关系：
点击事件产生，调用dispatchTouchEvent
如果 ViewGroup的onInterceptTouchEvent方法返回true 拦截该事件，然后call当前的ViewGroup的onTouchEvent方法；
如果当前ViewGroup的onInterceptTouchEvent方法返回false， 不拦截该事件，该事件会继续传递给它的子元素，子元素的dispatchTouchEvent被调用，…&lt;/p&gt;

&lt;p&gt;如果一个View设置了OnTouchListener，那么OnTouchListener中的onTouch方法会被调用。这时如果onTouch的返回true，View当前的onTouchEvent方法将不被调用；false，onTouchEvent方法将被调用。&lt;/p&gt;

&lt;p&gt;在onTouchEvent方法中，如果当前设置了OnClickListener，那么onClick方法将会被调用。&lt;/p&gt;

&lt;p&gt;由上可以看出，优先级为：OnTouchListener &amp;gt; onTouchEvent &amp;gt; OnClickListener&lt;/p&gt;

&lt;p&gt;当一个点击事件产生后，它的传递过程如下：
Activity，Window，View。View接收到事件后悔按照事件分发机制去分发事件。
子ViewonTouchEvent返回false，父元素OnTouchEvent事件被调用，依次向上直到Activity。&lt;/p&gt;

&lt;h2 id=&quot;view事件传递机制&quot;&gt;View事件传递机制&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;一个事件序列是指：从down事件开始，move…, 最终以up事件结束。&lt;/li&gt;
  &lt;li&gt;正常情况下，一个事件序列只能被一个View拦截且消耗。通过特殊手段（如将一个View自己该处理的事件通过onTouchEvent强行传递给其他View）处理。&lt;/li&gt;
  &lt;li&gt;某个View一旦拦截，那么事件序列都只能由它来处理，并且其onInterceptTouchEvent不会被再调用&lt;/li&gt;
  &lt;li&gt;View开始处理事件，如果不消耗ACTION_DOWN事件，那么同一事件序列中其他事件都不会再交给它来处理，父元素的onTouchEvent将会被调用，后续事件将不能接收到&lt;/li&gt;
  &lt;li&gt;如果View不消耗除ACTION_DOWN以外的其他事件，父元素的onTouchEvent不会被调用，可以收到后续事件，未被消耗的事件将传递给Activity&lt;/li&gt;
  &lt;li&gt;ViewGroup不拦截任何事件&lt;/li&gt;
  &lt;li&gt;View没有onInterceptTouchEvent&lt;/li&gt;
  &lt;li&gt;View的onTouchEvent默认都会被调用，除非clickable和longClickable同时为false&lt;/li&gt;
  &lt;li&gt;View的enable不影响onTouchEvent的默认返回值&lt;/li&gt;
  &lt;li&gt;onClick发生的前提是当前View是可点击的，并且收到了down和up事件。&lt;/li&gt;
  &lt;li&gt;事件总是先传递给父元素，然后父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以干预父元素的事件分发过程。&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">View事件的分发机制 View的一大难题：滑动冲突，解决办法就涉及到事件分发机制。</summary></entry><entry><title type="html">View Scroll</title><link href="http://localhost:4000/2017/02/26/View-Scroll.html" rel="alternate" type="text/html" title="View Scroll" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/View-Scroll</id><content type="html" xml:base="http://localhost:4000/2017/02/26/View-Scroll.html">&lt;h1 id=&quot;view滑动冲突&quot;&gt;View滑动冲突&lt;/h1&gt;
&lt;p&gt;View的滑动冲突产生场景有一下三种情况：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;内外均可滑动，且滑动方向不一致；&lt;/li&gt;
  &lt;li&gt;内外均可滑动，且滑动方向一致；&lt;/li&gt;
  &lt;li&gt;以上两种情况的嵌套（同时存在）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;滑动冲突解决规则&quot;&gt;滑动冲突解决规则&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;场景1
判断是有内还是外拦截事件:滑动起点到终点的X增量和Y增量来判断是水平滑动还是竖直滑动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景2
根据业务需求来制定规则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;场景3
同场景2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;冲突解决方式&quot;&gt;冲突解决方式&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;场景1
根据滑动距离来判断，这个距离差就是所谓的规则。解决思想：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;外部拦截：
外部拦截是指点击事件都先经过父容器的拦截器，适合点击事件的分发机制
外部拦截需要父容器的onInterceptTouchEvent方法&lt;/p&gt;

&lt;p&gt;内部拦截：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;父元素的onInterceptTouchEvent方法中不能拦截ACTION_DOWN，拦截其他事件。&lt;/li&gt;
  &lt;li&gt;ViewGroup&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">View滑动冲突 View的滑动冲突产生场景有一下三种情况：</summary></entry><entry><title type="html">Thread Pool</title><link href="http://localhost:4000/2017/02/26/Thread-Pool.html" rel="alternate" type="text/html" title="Thread Pool" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/Thread-Pool</id><content type="html" xml:base="http://localhost:4000/2017/02/26/Thread-Pool.html">&lt;p&gt;##线程池的优点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;线程池中的线程可以重用，减少线程创建、销毁带来的系统开销；&lt;/li&gt;
  &lt;li&gt;控制线程池的最大并发量，避免相互抢占系统资源而导致阻塞；&lt;/li&gt;
  &lt;li&gt;对线程进行简单管理，提供定时执行，以及指定间隔循环执行；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##ThreadPoolExecutor构造方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;corePoolSize
    &lt;blockquote&gt;
      &lt;p&gt;线程池的核心数&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;maximumPoolSize
    &lt;blockquote&gt;
      &lt;p&gt;线程池能容纳的最大线程数&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;keepAliveTime
    &lt;blockquote&gt;
      &lt;p&gt;非核心线程闲置时间的超时时长，超过这个时长，非核心线程就会被回收。ThreadPoolExecutor的allowCoreThreadTimeOut属性为true，keepAliveTime同样会作用于核心线程。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;unit
    &lt;blockquote&gt;
      &lt;p&gt;超时时长的单位，常用的有TimeUnit.MILISECONDS\TimeUnit.SECONDS\TimeUnit.MINUTES等&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;workQueue
    &lt;blockquote&gt;
      &lt;p&gt;线程池中的任务队列，通过线程池的execute方法提交Runnerable对象会存储在这个参数中&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;threadFactory
    &lt;blockquote&gt;
      &lt;p&gt;线程工厂&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##ThreadPoolExecutor执行任务的规则
设：nThreadNow: 为当前线程数量;
   nCore: 核心线程数量;
   nPoolMax: 线程池最大值&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;nThreadNow &amp;lt; nCore, 启动一个核心线程来执行任务;&lt;/li&gt;
  &lt;li&gt;nThreadNow &amp;gt;= nCore &amp;amp;&amp;amp; 工作队列未满, 将任务插入到工作队列;&lt;/li&gt;
  &lt;li&gt;工作队列已满 &amp;amp;&amp;amp; nThreadNow &amp;lt; nPoolMax, 立即启动一个非核心线程来执行任务;&lt;/li&gt;
  &lt;li&gt;nThreadNow &amp;gt;= nPoolMax, 拒绝执行此任务&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;##线程池的分类
Android中有四种常见的线程池：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;FixedThreadPool
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;线程数量固定&lt;/li&gt;
        &lt;li&gt;当线程处于空闲状态时，不会被回收&lt;/li&gt;
        &lt;li&gt;当所有的线程处于活动状态时，新任务都会处于等待状态，直到有线程空闲出来&lt;/li&gt;
        &lt;li&gt;只有&lt;font color=&quot;black&quot;&gt;**核心**&lt;/font&gt;线程&lt;/li&gt;
        &lt;li&gt;没有超时机制&lt;/li&gt;
        &lt;li&gt;任务队列没有大小限制&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;CachedThreadPool 适用于执行大量耗时较少的任务
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;线程数量不固定&lt;/li&gt;
        &lt;li&gt;只有&lt;font color=&quot;black&quot;&gt;**非核心**&lt;/font&gt;线程&lt;/li&gt;
        &lt;li&gt;线程池中的线程都处于活动状态，新建线程来处理新任务；否则利用空闲线程处理新任务&lt;/li&gt;
        &lt;li&gt;空闲线程都有超时机制&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;ScheduledThreadPool 适用于执行定时任务、具有固定周期的重复任务
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;核心线程数量固定&lt;/li&gt;
        &lt;li&gt;非核心线程数没有限制&lt;/li&gt;
        &lt;li&gt;非核心线程闲置时会被立即回收&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;SingleThreadPool
    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;内部只有一个核心线程&lt;/li&gt;
        &lt;li&gt;确保所有任务都在同一个线程中按顺序执行&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">##线程池的优点 线程池中的线程可以重用，减少线程创建、销毁带来的系统开销； 控制线程池的最大并发量，避免相互抢占系统资源而导致阻塞； 对线程进行简单管理，提供定时执行，以及指定间隔循环执行；</summary></entry><entry><title type="html">Aysnctask</title><link href="http://localhost:4000/2017/02/26/AysncTask.html" rel="alternate" type="text/html" title="Aysnctask" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/AysncTask</id><content type="html" xml:base="http://localhost:4000/2017/02/26/AysncTask.html">&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;AsyncTask是Android系统提供的异步方式，其优点在于在子线程执行任务，并将结果传递给主线程。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;实现方式&quot;&gt;实现方式&lt;/h3&gt;
&lt;p&gt;AsyncTask封装了Executor和Handler。&lt;/p&gt;

&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AsyncTask类必须在主线程汇总加载&lt;/li&gt;
  &lt;li&gt;AsyncTask对象必须在主线程中创建&lt;/li&gt;
  &lt;li&gt;execute方法必须在主线程中调用&lt;/li&gt;
  &lt;li&gt;onPreExecute() onPostExecute() doInBackground() onProgressUpdate()方法不要去显示调用
在Android3.0及以后使用executeOnExcutor方法来并行执行任务。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;本文并不是主要写如何使用AsyncTask，因此不作展开介绍。&lt;/p&gt;

&lt;h1 id=&quot;兼容性&quot;&gt;兼容性&lt;/h1&gt;
&lt;p&gt;本文主要介绍的是AsyncTask在不同的API版本中的区别。&lt;/p&gt;

&lt;h2 id=&quot;并行还是串行&quot;&gt;并行还是串行&lt;/h2&gt;
&lt;p&gt;下面的表格说明了AsyncTask的在不同API版本中，并行、串行情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Android1.5 ————execute——–串行&lt;/li&gt;
  &lt;li&gt;Android1.6~2.2 ——–execute——–并行&lt;/li&gt;
  &lt;li&gt;Android3.0+ ———–execute——–串行&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在Android3.0以后，如果要使用并行执行，那么需要调用executeOnExecutor方法。&lt;/p&gt;

&lt;h2 id=&quot;线程池&quot;&gt;线程池&lt;/h2&gt;
&lt;p&gt;在Android4.4以前，corePoolSize的值为5:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private static final int CORE_POOL_SIZE = 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.4以后改为当前CPU数量加1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private static final int CORE_POOL_SIZE = CPU_COUNT + 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;线程池的调度&quot;&gt;线程池的调度&lt;/h2&gt;
&lt;p&gt;设： nT为当前线程池的线程数量。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;nT &amp;gt;= corePoolSize &lt;strong&gt;且&lt;/strong&gt; workQueue未满，新任务直接加入workQueue&lt;/li&gt;
  &lt;li&gt;workQueue已满 &lt;strong&gt;且&lt;/strong&gt; nT &amp;lt; maximumPoolSize 新任务等待&lt;/li&gt;
  &lt;li&gt;nT &amp;gt;= maximumPoolSize &lt;strong&gt;且&lt;/strong&gt; workQueue已满，将会使用THREAD_POOL_EXECUTOR中的handler进行处理：&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;rejectedExecution&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runnable&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ThreadPoolExecutor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RejectedExecutionException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Task &quot;&lt;/span&gt; 
           &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; 
           &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; rejected from &quot;&lt;/span&gt; 
           &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h1 id=&quot;asynctask工作原理&quot;&gt;AsyncTask工作原理&lt;/h1&gt;
&lt;p&gt;从AsyncTask的execute方法入手：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}

@MainThread
public final AsyncTask&amp;lt;Params, Progress, Result&amp;gt; executeOnExecutor(Executor exec,
                                                                   Params... params) {
    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }
    mStatus = Status.RUNNING;
    onPreExecute(); 			//首先执行onPreExecute()
    mWorker.mParams = params; 	//将参数封装为mWorker的相关参数
    exec.execute(mFuture); 		//串行执行Task
    return this;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sDefaultExecutor是一个串行的线程池，一个进程汇总的所有AsyncTask全部在这个线程池中排队执行。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();

private static class SerialExecutor implements Executor {
    final ArrayDeque&amp;lt;Runnable&amp;gt; mTasks = new ArrayDeque&amp;lt;Runnable&amp;gt;();
    Runnable mActive;

    public synchronized void execute(final Runnable r) {
        mTasks.offer(new Runnable() {	//将FutureTask对象插入到任务队列中
            public void run() {
                try {
                    r.run();
                } finally {
                    scheduleNext();
                }
            }
        });
        if (mActive == null) { //如果没有正在活动的任务，那么就调用scheduleNext()来执行下一个任务
            scheduleNext();
        }
    }

    protected synchronized void scheduleNext() {
        if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;线程池THREAD_POOL_EXECUTOR用于真正的执行任务，InternalHandler用于将执行环境从线程池切换到主线程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;mWorker = new WorkerRunnable&amp;lt;Params, Result&amp;gt;() {
	//FutureTask的run方法会调用mWorker的call()方法，因此mWorker的call方法最终会在线程池中执行。
    public Result call() throws Exception {
        mTaskInvoked.set(true);	//当前任务已经被调用
        Result result = null;   //
        try {
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            //noinspection unchecked
            result = doInBackground(mParams);
            Binder.flushPendingCommands();
        } catch (Throwable tr) {
            mCancelled.set(true);
            throw tr;
        } finally {
            postResult(result);
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sHandler是一个静态Handler对象，sHandler收到MESSAGE_POST_RESULT这个消息后悔调用AsyncTask的finish方法.&lt;/p&gt;</content><author><name></name></author><summary type="html">简介 AsyncTask是Android系统提供的异步方式，其优点在于在子线程执行任务，并将结果传递给主线程。</summary></entry><entry><title type="html">Android6 Permission</title><link href="http://localhost:4000/2017/02/26/Android6-Permission.html" rel="alternate" type="text/html" title="Android6 Permission" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/Android6-Permission</id><content type="html" xml:base="http://localhost:4000/2017/02/26/Android6-Permission.html">&lt;h1 id=&quot;android权限申请&quot;&gt;Android权限申请&lt;/h1&gt;
&lt;p&gt;在Android 6.0（API &amp;lt; 23）以前，App用到的权限只需要在AndroidManifest文件中声明就好了。在6.0以后，权限策略进行了更改，权限分为一般权限和危险权限。一般权限跟以前一样不用动态申请，应用安装完毕就已经授予；危险权限需要在使用的使用动态申请。&lt;/p&gt;

&lt;h2 id=&quot;一般权限&quot;&gt;一般权限&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/topics/permissions/normal-permissions.html&quot;&gt;If an app declares in its manifest that it needs a normal permission, the system automatically grants the app that permission at install time&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面是一般权限列表：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ACCESS_LOCATION_EXTRA_COMMANDS&lt;/li&gt;
  &lt;li&gt;ACCESS_NETWORK_STATE&lt;/li&gt;
  &lt;li&gt;ACCESS_NOTIFICATION_POLICY&lt;/li&gt;
  &lt;li&gt;ACCESS_WIFI_STATE&lt;/li&gt;
  &lt;li&gt;BLUETOOTH&lt;/li&gt;
  &lt;li&gt;BLUETOOTH_ADMIN&lt;/li&gt;
  &lt;li&gt;BROADCAST_STICKY&lt;/li&gt;
  &lt;li&gt;CHANGE_NETWORK_STATE&lt;/li&gt;
  &lt;li&gt;CHANGE_WIFI_MULTICAST_STATE&lt;/li&gt;
  &lt;li&gt;CHANGE_WIFI_STATE&lt;/li&gt;
  &lt;li&gt;DISABLE_KEYGUARD&lt;/li&gt;
  &lt;li&gt;EXPAND_STATUS_BAR&lt;/li&gt;
  &lt;li&gt;GET_PACKAGE_SIZE&lt;/li&gt;
  &lt;li&gt;INSTALL_SHORTCUT&lt;/li&gt;
  &lt;li&gt;INTERNET&lt;/li&gt;
  &lt;li&gt;KILL_BACKGROUND_PROCESSES&lt;/li&gt;
  &lt;li&gt;MODIFY_AUDIO_SETTINGS&lt;/li&gt;
  &lt;li&gt;NFC&lt;/li&gt;
  &lt;li&gt;READ_SYNC_SETTINGS&lt;/li&gt;
  &lt;li&gt;READ_SYNC_STATS&lt;/li&gt;
  &lt;li&gt;RECEIVE_BOOT_COMPLETED&lt;/li&gt;
  &lt;li&gt;REORDER_TASKS&lt;/li&gt;
  &lt;li&gt;REQUEST_IGNORE_BATTERY_OPTIMIZATIONS&lt;/li&gt;
  &lt;li&gt;REQUEST_INSTALL_PACKAGES&lt;/li&gt;
  &lt;li&gt;SET_ALARM&lt;/li&gt;
  &lt;li&gt;SET_TIME_ZONE&lt;/li&gt;
  &lt;li&gt;SET_WALLPAPER&lt;/li&gt;
  &lt;li&gt;SET_WALLPAPER_HINTS&lt;/li&gt;
  &lt;li&gt;TRANSMIT_IR&lt;/li&gt;
  &lt;li&gt;UNINSTALL_SHORTCUT&lt;/li&gt;
  &lt;li&gt;USE_FINGERPRINT&lt;/li&gt;
  &lt;li&gt;VIBRATE&lt;/li&gt;
  &lt;li&gt;WAKE_LOCK&lt;/li&gt;
  &lt;li&gt;WRITE_SYNC_SETTINGS&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;危险权限&quot;&gt;危险权限&lt;/h2&gt;
&lt;p&gt;像读取联系人这样，企图获取涉及用户隐私的数据或资源、潜在影响用户存储的数据及操作其他应用的行为都触及危险权限。&lt;/p&gt;

&lt;p&gt;如果声明了危险权限，必须由用户授予相应的权限。&lt;/p&gt;

&lt;p&gt;危险权限一般都是一组权限，如果该组中的一个权限被授予，同组其他的权限都将被自动授予。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.android.com/guide/topics/permissions/requesting.html#normal-dangerous&quot;&gt;危险权限列表&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;动态权限申请&quot;&gt;动态权限申请&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;检查权限是否已经被授权&lt;/li&gt;
  &lt;li&gt;申请权限&lt;/li&gt;
  &lt;li&gt;如果已经授权成功，执行相关操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是相关代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;        // here, check the permission is granted or not
        if (ContextCompat.checkSelfPermission(mContext,
                Manifest.permission.CALL_PHONE)!=
                PackageManager.PERMISSION_GRANTED
        ) {
            // request permission
            ActivityCompat.requestPermissions(this,
                    new String[]{Manifest.permission.CALL_PHONE},
                    MY_PERMISSIONS_REQUEST_CALL_PHONE);
        } else {
            // do something
            callPhone(&quot;10086&quot;);
        }
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><summary type="html">Android权限申请 在Android 6.0（API &amp;lt; 23）以前，App用到的权限只需要在AndroidManifest文件中声明就好了。在6.0以后，权限策略进行了更改，权限分为一般权限和危险权限。一般权限跟以前一样不用动态申请，应用安装完毕就已经授予；危险权限需要在使用的使用动态申请。</summary></entry><entry><title type="html">Android Memory</title><link href="http://localhost:4000/2017/02/26/Android-Memory.html" rel="alternate" type="text/html" title="Android Memory" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/Android-Memory</id><content type="html" xml:base="http://localhost:4000/2017/02/26/Android-Memory.html">&lt;h1 id=&quot;android内存管理机制&quot;&gt;Android内存管理机制&lt;/h1&gt;
&lt;p&gt;本文主要讲述了Java内存分配机制、JavaGC机制，介绍了Dalvik虚拟机和ART虚拟机及其内存管理。&lt;/p&gt;

&lt;h2 id=&quot;java内存分配机制&quot;&gt;Java内存分配机制&lt;/h2&gt;
&lt;p&gt;对象将根据存活的时间被分为：&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;年轻代（Young Generation）:&lt;/strong&gt; 对象被创建时，内存的分配首先发生在年轻代。绝大多数刚创建的对象会被分配在Eden区（Eden区是连续的内存空间）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;老年代（Old Generation）:&lt;/strong&gt; 对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时， 将执行Major GC，也叫 Full GC。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;永久代（Permanent Generation，也就是方法区）:&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;java-gc机制&quot;&gt;Java GC机制&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Serial收集器：&lt;/strong&gt;新生代收集器，使用停止复制算法，使用一个线程进行GC，其它工作线程暂停。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;ParNew收集器：&lt;/strong&gt;新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，其它工作线程暂停，关注缩短垃圾收集时间。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Parallel Scavenge 收集器：&lt;/strong&gt;新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Serial Old收集器：&lt;/strong&gt;老年代收集器，单线程收集器，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存 的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Parallel Old收集器：&lt;/strong&gt;老年代收集器，多线程，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清 理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CMS（Concurrent Mark Sweep）收集器：&lt;/strong&gt;老年代收集器，致力于获取最短回收停顿时间，使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dalvik虚拟机&quot;&gt;Dalvik虚拟机&lt;/h2&gt;
&lt;p&gt;Dalvik虚拟机使用dex（Dalvik Executable）格式的文件，Java使用的是class文件。一个dex文件可以包含多个类，而class文件只能包含一个类。Dalvik虚拟机使用的指令时基于寄存器的，而Java虚拟机使用的指令集是基于堆栈的。&lt;/p&gt;

&lt;p&gt;Dalvik是依靠一个Just-In-Time (JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，让应用能更容易在不同硬件和架构上运行。&lt;/p&gt;

&lt;h3 id=&quot;dalvik-内存管理&quot;&gt;Dalvik 内存管理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Dalvik虚拟机用来分配对象的堆划分为2部分：&lt;strong&gt;Active Heap&lt;/strong&gt;和&lt;strong&gt;Zygote Heap&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;Android系统的第一个Dalvik虚拟机是由Zygote进程创建的，应用程序进程是由Zygote进程fork出来的。&lt;/li&gt;
  &lt;li&gt;当Zygote进程在fork第一个应用程序进程之前，会将已经使用了的那部分堆内存划分为一部分，还没有使用的堆内存划分为另外一部分。前者就称为Zygote堆，后者就称为Active堆。以后无论是Zygote进程，还是应用程序进程，当它们需要分配对象的时候，都在Active堆上进行。这样就可以使得Zygote堆尽可能少地被执行写操作。&lt;/li&gt;
  &lt;li&gt;在Zygote堆里面分配的对象其实主要就是Zygote进程在启动过程中预加载的类、资源和对象了。这意味着这些预加载的类、资源和对象可以在Zygote进程和应用程序进程中做到长期共享。&lt;/li&gt;
  &lt;li&gt;分配对象的堆划分为Active堆和Zygote堆，既能减少内存需求，也能减少拷贝操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;创建对象&quot;&gt;创建对象&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;调用函数dvmHeapSourceAlloc在Java堆上分配指定大小的内存。如果分配成功，那么就将分配得到的地址直接返回给调用者了。&lt;/li&gt;
  &lt;li&gt;如果上一步内存分配失败，这时候就需要执行一次GC了。调用函数gcForMalloc来执行一次GC了，参数false表示不要回收软引用对象引用的对象。&lt;/li&gt;
  &lt;li&gt;GC执行完毕后，再次调用函数dvmHeapSourceAlloc尝试轻量级的内存分配操作。如果分配成功，那么就将分配得到的地址直接返回给调用者了。&lt;/li&gt;
  &lt;li&gt;如果上一步内存分配失败，这时候就得考虑先将Java堆的当前大小设置为Dalvik虚拟机启动时指定的Java堆最大值，再进行内存分配了。&lt;/li&gt;
  &lt;li&gt;如果调用函数dvmHeapSourceAllocAndGrow分配内存成功，则直接将分配得到的地址直接返回给调用者了。&lt;/li&gt;
  &lt;li&gt;如果上一步内存分配还是失败，这时候就得出狠招了。再次调用函数gcForMalloc来执行GC。参数true表示要回收软引用对象引用的对象。&lt;/li&gt;
  &lt;li&gt;GC执行完毕，再次调用函数dvmHeapSourceAllocAndGrow进行内存分配。这是最后一次努力了，成功与事都到此为止。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#### GC类型 ####
 /* Not enough space for an “ordinary” Object to be allocated. */&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;extern const GcSpec *GC_FOR_MALLOC;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;/* Automatic GC triggered by exceeding a heap occupancy threshold. */&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;extern const GcSpec *GC_CONCURRENT;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;/* Explicit GC via Runtime.gc(), VMRuntime.gc(), or SIGUSR1. */&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;extern const GcSpec *GC_EXPLICIT;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;/* Final attempt to reclaim memory before throwing an OOM. */&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;extern const GcSpec *GC_BEFORE_OOM;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;art&quot;&gt;ART&lt;/h2&gt;
&lt;p&gt;在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time (AOT）编译。&lt;/p&gt;

&lt;h3 id=&quot;art的优势&quot;&gt;ART的优势&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;应用启动更快、运行更快、体验更流畅、触感反馈更及时&lt;/li&gt;
  &lt;li&gt;支持更低的硬件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;art的缺点&quot;&gt;ART的缺点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;存储空间占用量大&lt;/li&gt;
  &lt;li&gt;应用安装时间长&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;art内存管理&quot;&gt;ART内存管理&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ART运行时堆划分为四个空间，分别是Image Space、Zygote Space、Allocation Space和Large Object Space。其中，Image，Zygote and Allocation Space是在地址上连续的空间，称为Continuous Space，而Large Object Space是一些离散地址的集合，用来分配一些大对象，称为Discontinuous Space。&lt;/li&gt;
  &lt;li&gt;在Image Space和Zygote Space之间，隔着一段用来映射system@framework@boot.art@classes.oat文件的内存。而Image Space空间就包含了那些需要预加载的系统类对象。如果系统没有升级，那么以后每次系统启动只需要将文件system@framework@boot.art@classes.dex直接映射到内存即可，省去了创建各个类对象的时间。&lt;/li&gt;
  &lt;li&gt;Zygote Space和Allocation Space与Dalvik虚拟机垃圾收集机制中的Zygote堆和Active堆的作用是一样的。Zygote Space在Zygote进程和应用程序进程之间共享的，而Allocation Space则是每个进程独占的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;以空间换时间。&lt;/p&gt;</content><author><name></name></author><summary type="html">Android内存管理机制 本文主要讲述了Java内存分配机制、JavaGC机制，介绍了Dalvik虚拟机和ART虚拟机及其内存管理。</summary></entry><entry><title type="html">Android Gesturedetector</title><link href="http://localhost:4000/2017/02/26/Android-GestureDetector.html" rel="alternate" type="text/html" title="Android Gesturedetector" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/Android-GestureDetector</id><content type="html" xml:base="http://localhost:4000/2017/02/26/Android-GestureDetector.html">&lt;h1 id=&quot;gestture-detector&quot;&gt;Gestture Detector&lt;/h1&gt;
&lt;p&gt;手势检测，用于检测用户的单机、滑动、长按、双击等行为。&lt;/p&gt;

&lt;p&gt;常用方法：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法名&lt;/th&gt;
      &lt;th&gt;简要说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;onSingleTapUp&lt;/td&gt;
      &lt;td&gt;单击&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onFling&lt;/td&gt;
      &lt;td&gt;快速滑动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onScroll&lt;/td&gt;
      &lt;td&gt;拖动&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onLongPress&lt;/td&gt;
      &lt;td&gt;长按&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;onDoubleTap&lt;/td&gt;
      &lt;td&gt;双击&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;滑动&quot;&gt;滑动&lt;/h2&gt;
&lt;p&gt;滑动需要有过渡效果，提升用户体验，将主要用到Scroller。Scroller本身无法让View弹性滑动，需要和View.computeScroll()方法一起使用。&lt;/p&gt;

&lt;p&gt;Android中滑动的实现方式有三种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过View本身提供的scrollTo/scrollBy方法；&lt;/li&gt;
  &lt;li&gt;通过动画给View施加平移效果；&lt;/li&gt;
  &lt;li&gt;通过改变View的LayoutParams使得View重绘布局从而实现滑动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用动画&quot;&gt;使用动画&lt;/h3&gt;
&lt;p&gt;通过动画让一个View进行平移，主要是操作View的translationX和translationY属性，既可以采用传统的View动画，也可以采用属性动画。&lt;/p&gt;

&lt;h3 id=&quot;scroller的基本使用方法&quot;&gt;Scroller的基本使用方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
&lt;/code&gt;&lt;/pre&gt;</content><author><name></name></author><summary type="html">Gestture Detector 手势检测，用于检测用户的单机、滑动、长按、双击等行为。</summary></entry><entry><title type="html">Android Databinding</title><link href="http://localhost:4000/2017/02/26/Android-DataBinding.html" rel="alternate" type="text/html" title="Android Databinding" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/Android-DataBinding</id><content type="html" xml:base="http://localhost:4000/2017/02/26/Android-DataBinding.html">&lt;p&gt;#Data Binding
根据变量，自动赋值到各widget
##What
用一个变量绑定各个widget的值。
##Why
在Java文件中，只更改一个对象，而无须手动设置某个widget（TextView）的值。
##How&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.编写layout文件，这里的layout为：
    act_data_bind_demo.xml&lt;/p&gt;

  &lt;p&gt;这里需要先准备变量
    &lt;data&gt;
       &lt;variable name=&quot;user&quot; type=&quot;com.andy.infrastructure.bean.Customer&quot;&gt;&lt;/variable&gt;
    &lt;/data&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;在具体的widget上使用该变量
	&lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{user.name}&quot;&gt;&lt;/TextView&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;2.Binding data
上面的步骤完成后，需要先编译整个Project，因为在这个过程中会生成一些类：DataBindingUtil，ActDataBindDemoBinding&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：这里的ActDataBindDemoBinding是根据上面的布局文件的名字生成的。&lt;/p&gt;

&lt;p&gt;在onCreate方法中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ActDataBindDemoBinding binding = DataBindingUtil.setContentView(this, 
         R.layout.act_data_bind_demo);

customer = new Customer();
customer.setName(&quot;Andy&quot;);
customer.setMobile(&quot;13866668888&quot;);

binding.setUser(customer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行后，可以看到页面中的两个TextView都有值。&lt;/p&gt;

&lt;p&gt;###问题：如何获取EditText的输入内容？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;failed：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;EditText
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:inputType=&quot;textEmailAddress&quot;
   android:text=&quot;@{user.email}&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;It’s work：&lt;/strong&gt; “&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...android:text=&quot;@={user.email}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###问题：如何通过一个按钮改变当前页面中的TextView的值？
1.module类继承BaseObservable&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Customer extends BaseObservable {
...
public void setMobile(String mobile) {
    this.mobile = mobile;
    notifyPropertyChanged(BR.mobile);
} 继承BaseObservable，同时在setter方法中调用notifyPropertyChanged。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.更新Java中的Customer对象，例如当mobile改变，UI会制动刷新。&lt;/p&gt;

&lt;p&gt;###Custom Binding Class Names
默认情况下，Binding Class是根据layout文件名生成的。（例如，当layout文件为act_data_bind_demo.xml，生成的class为：ActDataBindDemoBinding）&lt;/p&gt;

&lt;p&gt;可以自定义类名，以及设定包名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;data class=&quot;com.andy.infrastructure.demos.databinding.DataBind&quot;&amp;gt;
    &amp;lt;variable ...
&amp;lt;/data&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码中，会在包com.andy.infrastructure.demos.databinding下生成一个名为DataBind的类。&lt;strong&gt;注意&lt;/strong&gt;这个package必须是存在的，当然也可以不指定package（会在默认的包下生成该类）。&lt;/p&gt;

&lt;p&gt;###Include
在layout文件中使用include时，也可以传递数据到指定的layout中。需要额外2个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;确保传递的变量在两个layout中都有声明&lt;/p&gt;

    &lt;layout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:bind=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
 &lt;data class=&quot;com.andy.infrastructure.demos.databinding.DataBind&quot;&gt;
     &lt;variable name=&quot;user&quot; type=&quot;com.andy.infrastructure.demos.databinding.Customer&quot; /&gt;
     ...
 &lt;/data&gt;
 ...
     &lt;include layout=&quot;@layout/user_name&quot; bind:user=&quot;@{user}&quot; /&gt;

 被引入的layout：
 ...
 &lt;data&gt;
     &lt;variable name=&quot;user&quot; type=&quot;com.andy.infrastructure.demos.databinding.Customer&quot; /&gt;
 &lt;/data&gt;

 &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;15dp&quot; android:text=&quot;@{user.name}&quot;&gt;

&lt;/TextView&gt;&lt;/layout&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;外层layout中传递变量&lt;/p&gt;

    &lt;include layout=&quot;@layout/user_name&quot; bind:user=&quot;@{user}&quot; /&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;###Expression Language&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数学运算 + - / * % &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;字符串拼接 + &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;逻辑运算符 &amp;amp;&amp;amp;&lt;/td&gt;
          &lt;td&gt; &lt;/td&gt;
          &lt;td&gt;&lt;br /&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;位运算 &amp;amp;&lt;/td&gt;
          &lt;td&gt;^ &lt;br /&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;Unary + - ! ~  &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;位移 » »&amp;gt; « &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;比较运算符 == &amp;gt; &amp;lt; &amp;gt;= &amp;lt;= &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;instanceof &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Grouping () &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Literals character, String, numeric, null &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Cast &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Method calls &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Field access &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Array access [] &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;三元运算符 ? : &lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Null Coalescing Operator ??
    &lt;blockquote&gt;
      &lt;p&gt;如果??左边不为空就使用左边值，否则就使用右边的值。&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;android:text=”@{user.displayName ?? user.lastName}”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的代码相当于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;android:text=&quot;@{user.displayName != null ? user.displayName : user.lastName}&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###Data Objects
三种数据更新提示机制：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Observable Object&lt;/li&gt;
    &lt;li&gt;Observable Fields&lt;/li&gt;
    &lt;li&gt;Observable Collections&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;####Observable Object
这种方式，需要做三个步骤：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;继承BaseObservable&lt;/li&gt;
    &lt;li&gt;为getter添加@Bindable&lt;/li&gt;
    &lt;li&gt;在setter中添加代码notifyPropertyChanged(BR.name);&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;###Views With IDs&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A public final field will be generated for each View with an ID in the layout. The binding does a single pass on the View hierarchy, extracting the Views with IDs. This mechanism can be faster than calling findViewById for several Views.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;layout文件中widget有设置id时，可以使用bind对象直接访问该控件，省去findViewById&lt;/p&gt;

&lt;h2 id=&quot;event-handling&quot;&gt;Event Handling&lt;/h2&gt;
&lt;h3 id=&quot;绑定onclick事件&quot;&gt;绑定OnClick事件&lt;/h3&gt;
&lt;p&gt;首先定义一个Presenter。在该类中提供一个方法onClick去完成点击事件的逻辑处理，该方法有2个参数view和dataFrg。因为这里需要改变dataFrg中的cbText属性的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public class MaterialPresenter {
    public void onClick(View view, DataFrg dataFrg) {
        switch (view.getId()) {
            case R.id.btn_change_text:
                dataFrg.setCbText(&quot;Text is ...&quot;);
                break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在layout中调用该方法：&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;Button&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;android:id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@+id/btn_change_text&quot;&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;android:layout_width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;match_parent&quot;&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;android:layout_height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;wrap_content&quot;&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;android:text=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;点击更换CheckBox文字&quot;&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;android:onClick=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;@{(view)-&amp;gt;presenter.onClick(view, dataFrg)}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;别忘记在Activity中绑定presenter变量&lt;/p&gt;

&lt;h2 id=&quot;advanced-binding&quot;&gt;Advanced Binding&lt;/h2&gt;
&lt;h3 id=&quot;dynamic-variables&quot;&gt;Dynamic Variables&lt;/h3&gt;
&lt;p&gt;在一些特殊情况下，DataBind类对应的layout是未知的，比如RecyclerView.Adapter。在onBindViewHolder方法中可以使用BindingHolder.getBinding()方法返回一个ViewDataBinding对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;public void onBindViewHolder(BindingHolder holder, int position) {
   final T item = mItems.get(position);
   holder.getBinding().setVariable(BR.item, item);
   holder.getBinding().executePendingBindings();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;attribute-setters&quot;&gt;Attribute Setters&lt;/h2&gt;</content><author><name></name></author><summary type="html">#Data Binding 根据变量，自动赋值到各widget ##What 用一个变量绑定各个widget的值。 ##Why 在Java文件中，只更改一个对象，而无须手动设置某个widget（TextView）的值。 ##How 1.编写layout文件，这里的layout为： act_data_bind_demo.xml 这里需要先准备变量</summary></entry><entry><title type="html">Android Anamation</title><link href="http://localhost:4000/2017/02/26/Android-Anamation.html" rel="alternate" type="text/html" title="Android Anamation" /><published>2017-02-26T00:00:00+08:00</published><updated>2017-02-26T00:00:00+08:00</updated><id>http://localhost:4000/2017/02/26/Android-Anamation</id><content type="html" xml:base="http://localhost:4000/2017/02/26/Android-Anamation.html">&lt;h2 id=&quot;动画分类&quot;&gt;动画分类&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;动画类型&lt;/th&gt;
      &lt;th&gt;说明&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;View动画&lt;/td&gt;
      &lt;td&gt;通过对场景里的对象不断做图像变换(平移、缩放、旋转、透明度)从而产生动画效果——渐进式动画&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;帧动画&lt;/td&gt;
      &lt;td&gt;通过顺序播放一系列图像从而产生动画效果——切片动画&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;属性动画&lt;/td&gt;
      &lt;td&gt;通过动态地改变对象的属性从而达到动画效果&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;view动画&quot;&gt;View动画&lt;/h2&gt;

&lt;p&gt;作用对象：View&lt;/p&gt;

&lt;p&gt;4种动画效果：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;标签&lt;/th&gt;
      &lt;th&gt;子类&lt;/th&gt;
      &lt;th&gt;效果&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;平移&lt;/td&gt;
      &lt;td&gt;&lt;translate&gt;&lt;/translate&gt;&lt;/td&gt;
      &lt;td&gt;TranslateAnimation&lt;/td&gt;
      &lt;td&gt;移动View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;缩放&lt;/td&gt;
      &lt;td&gt;&lt;scale&gt;&lt;/scale&gt;&lt;/td&gt;
      &lt;td&gt;ScaleAnimation&lt;/td&gt;
      &lt;td&gt;放大或缩小View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;旋转&lt;/td&gt;
      &lt;td&gt;&lt;rotate&gt;&lt;/rotate&gt;&lt;/td&gt;
      &lt;td&gt;RotateAnimation&lt;/td&gt;
      &lt;td&gt;旋转View&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;透明度&lt;/td&gt;
      &lt;td&gt;&lt;alpha&gt;&lt;/alpha&gt;&lt;/td&gt;
      &lt;td&gt;AlphaAnimation&lt;/td&gt;
      &lt;td&gt;改变View的透明度&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;如果把轴点设为View的右边界，那么View就只会向左边进行缩放，反之则向右边进行缩放。&lt;/p&gt;

&lt;p&gt;android:duration——动画的持续时间
android:fillAfter——动画结束以后View是否停留在结束位置&lt;/p&gt;

&lt;h4 id=&quot;自定义动画&quot;&gt;自定义动画&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;继承Animation&lt;/li&gt;
  &lt;li&gt;重写initialize，在其中做一些初始化工作&lt;/li&gt;
  &lt;li&gt;重写applyTransformation，在其中进行相应的矩阵变换&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;enterAnim——Activity被打开时，所需的动画资源id
exitAnim——Activity被暂停时，所需的动画资源id&lt;/p&gt;

&lt;p&gt;Activity切换动画主要代码：&lt;br /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;Intent intent = new Intent(this, TestActivity.class);
startActiviyt(intent);
overridePendingTransition(R.anim.enter, R.anim.exit);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fragment也可以切换动画： &lt;br /&gt;
通过FragmentTransaction中的setCustomAnimations()方法来添加切换动画&lt;/p&gt;

&lt;h2 id=&quot;属性动画&quot;&gt;属性动画&lt;/h2&gt;
&lt;h4 id=&quot;属性动画的基本信息&quot;&gt;属性动画的基本信息&lt;/h4&gt;
&lt;p&gt;属性动画可以对任意对象做动画。&lt;br /&gt;
属性动画中有ValueAnimator、ObjectAnimator和AnimatorSet&lt;br /&gt;
动画默认时间间隔：300ms，默认帧率10ms/帧&lt;br /&gt;
可以达到的效果：在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。&lt;br /&gt;
只要对象有这个属性，属性动画都能实现动画效果。&lt;br /&gt;
从API11开始&lt;/p&gt;

&lt;h4 id=&quot;如何使用属性动画&quot;&gt;如何使用属性动画&lt;/h4&gt;</content><author><name></name></author><summary type="html">动画分类</summary></entry></feed>