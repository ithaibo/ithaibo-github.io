<p>#Data Binding
根据变量，自动赋值到各widget
##What
用一个变量绑定各个widget的值。
##Why
在Java文件中，只更改一个对象，而无须手动设置某个widget（TextView）的值。
##How</p>
<blockquote>
  <p>1.编写layout文件，这里的layout为：
    act_data_bind_demo.xml</p>

  <p>这里需要先准备变量
    <data>
       <variable name="user" type="com.andy.infrastructure.bean.Customer"></variable>
    </data></p>
</blockquote>

<blockquote>
  <p>在具体的widget上使用该变量
	<TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@{user.name}"></TextView></p>
</blockquote>

<hr />
<blockquote>
  <p>2.Binding data
上面的步骤完成后，需要先编译整个Project，因为在这个过程中会生成一些类：DataBindingUtil，ActDataBindDemoBinding</p>
</blockquote>

<hr />
<p><strong>注意</strong>：这里的ActDataBindDemoBinding是根据上面的布局文件的名字生成的。</p>

<p>在onCreate方法中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ActDataBindDemoBinding binding = DataBindingUtil.setContentView(this, 
         R.layout.act_data_bind_demo);

customer = new Customer();
customer.setName("Andy");
customer.setMobile("13866668888");

binding.setUser(customer);
</code></pre>
</div>

<p>运行后，可以看到页面中的两个TextView都有值。</p>

<p>###问题：如何获取EditText的输入内容？</p>

<p><strong>failed：</strong></p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;EditText
   android:layout_width="match_parent"
   android:layout_height="wrap_content"
   android:inputType="textEmailAddress"
   android:text="@{user.email}"/&gt;
</code></pre>
</div>

<p><strong>It’s work：</strong> “</p>

<div class="highlighter-rouge"><pre class="highlight"><code>...android:text="@={user.email}"
</code></pre>
</div>

<p>###问题：如何通过一个按钮改变当前页面中的TextView的值？
1.module类继承BaseObservable</p>

<div class="highlighter-rouge"><pre class="highlight"><code>public class Customer extends BaseObservable {
...
public void setMobile(String mobile) {
    this.mobile = mobile;
    notifyPropertyChanged(BR.mobile);
} 继承BaseObservable，同时在setter方法中调用notifyPropertyChanged。
</code></pre>
</div>

<p>2.更新Java中的Customer对象，例如当mobile改变，UI会制动刷新。</p>

<p>###Custom Binding Class Names
默认情况下，Binding Class是根据layout文件名生成的。（例如，当layout文件为act_data_bind_demo.xml，生成的class为：ActDataBindDemoBinding）</p>

<p>可以自定义类名，以及设定包名：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>&lt;data class="com.andy.infrastructure.demos.databinding.DataBind"&gt;
    &lt;variable ...
&lt;/data&gt;
</code></pre>
</div>

<p>上面的代码中，会在包com.andy.infrastructure.demos.databinding下生成一个名为DataBind的类。<strong>注意</strong>这个package必须是存在的，当然也可以不指定package（会在默认的包下生成该类）。</p>

<p>###Include
在layout文件中使用include时，也可以传递数据到指定的layout中。需要额外2个步骤：</p>

<ol>
  <li>
    <p>确保传递的变量在两个layout中都有声明</p>

    <layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:bind="http://schemas.android.com/apk/res-auto">
 <data class="com.andy.infrastructure.demos.databinding.DataBind">
     <variable name="user" type="com.andy.infrastructure.demos.databinding.Customer" />
     ...
 </data>
 ...
     <include layout="@layout/user_name" bind:user="@{user}" />

 被引入的layout：
 ...
 <data>
     <variable name="user" type="com.andy.infrastructure.demos.databinding.Customer" />
 </data>

 <TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:padding="15dp" android:text="@{user.name}">

</TextView></layout>
  </li>
  <li>
    <p>外层layout中传递变量</p>

    <include layout="@layout/user_name" bind:user="@{user}" />
  </li>
</ol>

<p>###Expression Language</p>

<ul>
  <li>数学运算 + - / * % <br /></li>
  <li>字符串拼接 + <br /></li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>逻辑运算符 &amp;&amp;</td>
          <td> </td>
          <td><br /></td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>位运算 &amp;</td>
          <td>^ <br /></td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>Unary + - ! ~  <br /></li>
  <li>位移 » »&gt; « <br /></li>
  <li>比较运算符 == &gt; &lt; &gt;= &lt;= <br /></li>
  <li>instanceof <br /></li>
  <li>Grouping () <br /></li>
  <li>Literals character, String, numeric, null <br /></li>
  <li>Cast <br /></li>
  <li>Method calls <br /></li>
  <li>Field access <br /></li>
  <li>Array access [] <br /></li>
  <li>
    <p>三元运算符 ? : <br /></p>
  </li>
  <li>Null Coalescing Operator ??
    <blockquote>
      <p>如果??左边不为空就使用左边值，否则就使用右边的值。</p>
    </blockquote>

    <p>android:text=”@{user.displayName ?? user.lastName}”</p>
  </li>
</ul>

<p>上面的代码相当于：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>android:text="@{user.displayName != null ? user.displayName : user.lastName}"
</code></pre>
</div>

<p>###Data Objects
三种数据更新提示机制：</p>
<blockquote>
  <ul>
    <li>Observable Object</li>
    <li>Observable Fields</li>
    <li>Observable Collections</li>
  </ul>
</blockquote>

<p>####Observable Object
这种方式，需要做三个步骤：</p>
<blockquote>
  <ul>
    <li>继承BaseObservable</li>
    <li>为getter添加@Bindable</li>
    <li>在setter中添加代码notifyPropertyChanged(BR.name);</li>
  </ul>
</blockquote>

<p>###Views With IDs</p>
<blockquote>
  <p>A public final field will be generated for each View with an ID in the layout. The binding does a single pass on the View hierarchy, extracting the Views with IDs. This mechanism can be faster than calling findViewById for several Views.</p>
</blockquote>

<p>layout文件中widget有设置id时，可以使用bind对象直接访问该控件，省去findViewById</p>

<h2 id="event-handling">Event Handling</h2>
<h3 id="绑定onclick事件">绑定OnClick事件</h3>
<p>首先定义一个Presenter。在该类中提供一个方法onClick去完成点击事件的逻辑处理，该方法有2个参数view和dataFrg。因为这里需要改变dataFrg中的cbText属性的值。</p>
<pre><code class="language-Java">public class MaterialPresenter {
    public void onClick(View view, DataFrg dataFrg) {
        switch (view.getId()) {
            case R.id.btn_change_text:
                dataFrg.setCbText("Text is ...");
                break;
        }
    }
}
</code></pre>

<p>在layout中调用该方法：</p>
<div class="language-xml highlighter-rouge"><pre class="highlight"><code><span class="nt">&lt;Button</span>
   <span class="na">android:id=</span><span class="s">"@+id/btn_change_text"</span>
   <span class="na">android:layout_width=</span><span class="s">"match_parent"</span>
   <span class="na">android:layout_height=</span><span class="s">"wrap_content"</span>
   <span class="na">android:text=</span><span class="s">"点击更换CheckBox文字"</span>
   <span class="na">android:onClick=</span><span class="s">"@{(view)-&gt;presenter.onClick(view, dataFrg)}"</span><span class="nt">/&gt;</span>
</code></pre>
</div>

<p><strong>注：</strong>别忘记在Activity中绑定presenter变量</p>

<h2 id="advanced-binding">Advanced Binding</h2>
<h3 id="dynamic-variables">Dynamic Variables</h3>
<p>在一些特殊情况下，DataBind类对应的layout是未知的，比如RecyclerView.Adapter。在onBindViewHolder方法中可以使用BindingHolder.getBinding()方法返回一个ViewDataBinding对象。</p>
<pre><code class="language-Java">public void onBindViewHolder(BindingHolder holder, int position) {
   final T item = mItems.get(position);
   holder.getBinding().setVariable(BR.item, item);
   holder.getBinding().executePendingBindings();
}
</code></pre>

<h2 id="attribute-setters">Attribute Setters</h2>
