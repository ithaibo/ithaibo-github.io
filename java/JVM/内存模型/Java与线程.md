# Java线程的实现
基于操作系统原生线程模型来实现

# Java线程调度
协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作完成后，要主动通知系统切换到另一个线程上。
抢占式线程调度：由系统来分配执行时间

# 线程安全
当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

## 安全程度
1. 不可变
2. 绝对线程安全
3. 相对线程安全
4. 线程兼容
5. 线程对立

## 不可变
- 基本数据类型：在定义时使用final关键字修饰就可以保证它是不变的
- 共享的是一个对象：保证对象的行为不会对其状态产生任何影响


## 线程安全的实现方法
1. 互斥同步
2. 非阻塞同步
3. 无同步方案

### 互斥同步
互斥是因，同步是果；互斥是方法，同步是目的。

实现同步的手段有：
- 临界区
- 互斥量
- 信号量

互斥同步的实现手段：
- synchronized
- 重入锁（ReentrantLock）

#### synchronized
编译后，会在同步块的前后分别形成monitorenter和monitorexit2个字节码指令。这2个字节码指令需要一个reference类型的参数来知名要锁定和解锁的对象。

synchronized的原理：
- 执行monitorenter时对象未锁定，或当前已经拥有该对象的锁，把锁的计数器加1；
- 执行monitorexit时，锁计数器减1；
- 计数器为0时，锁被释放
- 获取对象的锁失败，当前线程将被阻塞，直到对象锁被其他线程释放

synchronized特点：
- 可重入
- 重量级操作：阻塞或唤醒一个线程，都需要操作系统来帮助完成，需要从用户态到内核态的来回切换。
- 原生语法层面的互斥锁


#### ReentrantLock

特点：
- 可重入
- 互斥锁
- API层面的互斥锁
    - lock
    - unlock

高级功能：
- 等待可中断
  - 当前持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待
  - 对处理执行时间非常长的同步代码块很有帮助
- 可实现公平锁
  - 多个线程等待同一个锁是，必须按照申请锁的先后顺序来依次获得锁
- 锁可以绑定多个条件


### 非阻塞同步
基于冲突检测的乐观并发策略。

特点：
  - 不需要将线程挂起
  - 需要硬件指令集的支持
    - Test-and-Set
    - Fetch-and-Increment
    - Swap
    - Compare-and-Swap
      - Unsafe
      - 原子类的compareAndSet() getAndIncrement
    - Load-Linked/Store-Condiational

### 无同步方案
- 可重入代码
  - 不依赖存储在堆上的数据和公用系统资源
  - 用到的状态量都由参数中传入
  - 不调用非可重入方法
  - 输入相同的数据，就都能返回相同的结果
- 线程本地存储
   - 把数据的可见性控制在线程之内
   - 每个线程的Thread对象中都有一个ThreadLocalMap对象
     - ThreadLocal.threadLocalHashCode为键，本地线程变量为值的KV对


## 锁优化
- 适应性自旋
- 锁消除
- 锁粗化
- 轻量级锁
- 偏向锁

为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

子适应自旋锁：自旋时间不再固定，而是由上一次在同一个锁上的自旋时间集锁拥有者的状态来决定

依据逃逸分析技术来检测不可能存在共享数据竞争的锁，对其进行消除

### 轻量级锁执行过程
1. 在当前线程栈帧中建立一个名为锁记录的空间，用于存储对象目前的Mark Word的拷贝
2. 虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针
3. 如果更新失败了，虚拟机检测对象的MarkWord是否指向当前线程的栈帧
   - 如果是，说明线程已经拥有了这个对象的锁，就可以直接进入同步块继续执行
   - 否则，如果有2条以上的线程争用同一个锁，轻量级锁就不再有效，要膨胀为重量级锁


偏向锁：锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步