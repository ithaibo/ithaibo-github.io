# Java内存模型
内存模型是一套共享内存系统中多线程读写操作行为的规范。这套规范屏蔽了底层各种硬件和操作系统内存访问差异。解决了CPU多级缓存、CPU优化、指令重排等导致的内存访问问题。保证了Java多线程程序在各种平台下对内存访问的一致性。

## 目的
保证Java多线程程序在各种平台下对内存访问的一致性

## 相关概念
1. 主内存
2. 共享变量
   - 存储在主内存中
3. 线程私有工作内存
   - 存储线程读写共享变量的副本
   - 线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量
   - 不同的线程之间不能直接访问对方的工作内存
   - 线程间的变量值传递均需要通过主内存来完成
   - 虚拟机可能会让工作内存优先存储于寄存器和高速缓存中
4. 内存可见性
   - 让应用程序免于数据竞争干扰
5. 原子性
6. 有序性

## happens-before规则
用于描述2个操作的内存可见性。如果操作A happens-before操作B，那么操作A的执行结果将对操作B可见。

1. 以下几种自动符合happens-before规则
   - 程序次序规则
     - 单线程内部，如果代码的字节码顺隐式符合happens-before
   - 锁定规则
     - 无论是在单线程还是多线程环境中，一个锁如果处于锁定状态，那么必须先执行unlock操作后才能进行unlock操作。
   - 变量规则
     - volatile保证了线程可见性
   - 线程启动规则
     - Thread对象的start()方法先行发生于此线程的每一个动作
   - 线程中断规则
     - 对线程interrupt()方法的调用先行发生于被中断线程的代码检测，直到到中断事件的发生
   - 线程终结规则
     - 线程中的所有操作都先行发生于对此线程的终止检测
   - 对象终结规则
     - 一个对象的初始化完成发生在它的finalize()方法开始前

## 内存模型的应用
1. volatile
``` Java
private volatile int value = 0;
public void setValue(int value) {
    this.value = value;
}
public int getValue() {
    return this.value;
}
```

2. synchronized
``` Java
private int value = 0;
public void setValue(int value) {
    synchronized {
        this.value = value;
    }
}
public int getValue() {
    synchronized {
        return this.value;
    }
}
```

## 内存间交互操作[1]
- 如何从主内存拷贝到工作内存
- 如何从工作内存同步到主内存
### 为了实现以上2种操作情况，Java内存模型定义了8种操作
1. lock
    - 作用于祝内存的变量
    - 把一个变量标识为一条线程独占的状态
2. unlock
    - 作用于主内存的变量
    - 把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
3. read
    - 作用于主内存的变量
    - 把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
4. load
    - 作用于工作内存的变量，
    - 把read操作从主内存中得到的变量值放入工作内存的变量副本中
5. use
    - 作用域工作内存变量
    - 把工作内存中一个变量的值传递给执行引擎
    - 虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作
6. assign
    - 作用于工作内存
    - 把一个执行引擎接收到的值赋给工作内存的变量
7. store
    - 作用于工作内存的变量
    - 把工作内存中的一个变量的值传递到主内存中，以便随后的write操作使用
8. write
    - 作用于主内存中的变量
    - 把store操作从工作内存中得到的变量的值放到主内存的变量中
### 把一个变量从主内存复制到工作内存
顺序执行read 和 load操作
### 把一个变量从工作内存同步到主内存
顺序执行store write操作

### 执行上述8种规则必须满足
1. 不允许read和load，store和write操作之一单独出现
2. 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步到祝内存中
3. 不允许一个线程没有发生assign操作时把数据从线程的工作内存同步到主内存中
4. 新的对象只能在主内存中“诞生”
5. 一个变量在同一个时刻只允许一条线程对其进行lock操作。但lock操作可以被同一个线程重复执行多次。多次执行lock后，必须执行相同次数的unlock操作才能解锁
6. 对一个变量执行lock操作，将会清空工作内存中此变量的值。在执行引擎使用这个变量钱，需要重新执行load或assign操作初始化变量的值
7. 没有被lock操作锁定，不允许执行unlock
8. 对一个变量执行unlock操作前，必须把变量同步回主内存中（执行store write操作）

## volatile型变量的特殊规则


## QA
1. C/C++直接使用物理硬件和操作系统内存模型？

2. 操作系统内存模型是什么？


## 参考文献
[1] 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》